author: Jeffrey Wilkinson
core-version: >=5.1.10
created: 20160216174754936
dependents: 
description: flexible types
list: readme license
modified: 20160216174754936
plugin-type: plugin
source: https://github.com/buggyj/TW5-flexitype
title: $:/plugins/bj/flexitype
type: application/json
version: 0.0.5

{
    "tiddlers": {
        "$:/core/modules/parsers/wikiparser/abstractwikiparser.js": {
            "text": "/*\\\ntitle: $:/core/modules/parsers/wikiparser/abstractwikiparser.js\ntype: application/javascript\nmodule-type: global\n\nbase class- individual wikiparser inherit from this class\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar AbstrWikiParser = function(specifier) {\n\t\n\tthis.type = specifier.type;\n\tthis.source = specifier.source;\n\tthis.options =specifier.options;\n\tthis.wiki = this.options.wiki;\n\tthis.pragmaRuleClasses=specifier.pragmaRuleClasses;\n\tthis.blockRuleClasses=specifier.blockRuleClasses;\n\tthis.inlineRuleClasses=specifier.inlineRuleClasses;\n\tthis.sourceLength = this.source.length;\n\t// Set current parse position\n\tthis.pos = 0;\n\t// Instantiate the pragma parse rules\n\tthis.pragmaRules = this.instantiateRules(this.pragmaRuleClasses,\"pragma\",0);\n\t// Instantiate the parser block and inline rules\n\tthis.blockRules = this.instantiateRules(this.blockRuleClasses,\"block\",0);\n\tthis.inlineRules = this.instantiateRules(this.inlineRuleClasses,\"inline\",0);\n\t// Parse any pragmas\n\tthis.tree = [];\n\tvar topBranch = this.parsePragmas();\n\t// Parse the text into inline runs or blocks\n\tif(this.options.parseAsInline) {\n\t\ttopBranch.push.apply(topBranch,this.parseInlineRun());\n\t} else {\n\t\ttopBranch.push.apply(topBranch,this.parseBlocks());\n\t}\n\t// Return the parse tree\n};\n\nAbstrWikiParser.prototype =Object.create( \n\trequire(\"$:/core/modules/parsers/wikiparser/wikiparser.js\")[\"text/vnd.tiddlywiki\"].prototype);\n\nexports[\"AbstrWikiParser\"] = AbstrWikiParser;\n\n})();\n",
            "title": "$:/core/modules/parsers/wikiparser/abstractwikiparser.js",
            "type": "application/javascript",
            "module-type": "global"
        },
        "$:/core/modules/parsers/wikiparser/basewikiparser.js": {
            "text": "/*\\\ntitle: $:/core/modules/parsers/wikiparser/basewikiparser.js\ntype: application/javascript\nmodule-type: parser\n\nThe base wiki text parser\n\nThis implementation is sub-optional, it 'steals' its defintion from the text/vnd.tiddlywiki,\nit would be better that the text/vnd.tiddlywiki was split into an abstract base and a realisation\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nfunction override(a, b) {\n  var hash = {};\n  return a.concat(b).filter(function (val) {\n    return hash[val] ? 0 : hash[val] = 1;\n  });\n}\nvar createClassesList= function (ruleList,userlist,nativelist) {\n\tvar temp ={};\n\tfor (var i=0;i<ruleList.length;i++) {\n\t\tvar rule = ruleList[i];\n\t\tvar found = false;\n\t\tif (!!userlist) \n\t\t\tif (Object.prototype.hasOwnProperty.call(userlist,rule)) {\n\t\t\t\ttemp[rule] = userlist[rule];\n\t\t\t\tfound = true; \n\t\t\t}\n\t\tif (!found) \n\t\t\tif (Object.prototype.hasOwnProperty.call(nativelist,rule)) {\n\t\t\t\ttemp[rule] = nativelist[rule];\n\t\t\t}\n\t\t\n\t}\n\treturn temp;\n};\nvar ParserPrimer = function(type,text,options) {\n\t//BJ meditation if I pass in the complete type here, then I could use this to cache the \n\t//Parser objects.\n\tif(!this.pragmaRuleClasses) {\n\t\tParserPrimer.prototype.pragmaRuleClasses = $tw.modules.createClassesFromModules(\"wikirule\",\"pragma\",$tw.WikiRuleBase);\n\t}\n\tif(!this.blockRuleClasses) {\n\t\tParserPrimer.prototype.blockRuleClasses = $tw.modules.createClassesFromModules(\"wikirule\",\"block\",$tw.WikiRuleBase);\n\t}\n\tif(!this.inlineRuleClasses) {\n\t\tParserPrimer.prototype.inlineRuleClasses = $tw.modules.createClassesFromModules(\"wikirule\",\"inline\",$tw.WikiRuleBase);\n\t}\n\tif(!this.userClasses) {\n\t\tParserPrimer.prototype.userClasses = $tw.modules.createClassesFromModules(\"wikirule\",\"user\",$tw.WikiRuleBase);\n\t}\n\n    if (!!options.parserrules) {//if($tw.browser)alert(\"createrules\");\n\t\tif (!!options.parserrules.pragmaRuleList)this.pragmaRuleClasses=createClassesList(options.parserrules.pragmaRuleList, this.userClasses, this.pragmaRuleClasses);\n\t\tif (!!options.parserrules.blockRuleList)this.blockRuleClasses=createClassesList(options.parserrules.blockRuleList, this.userClasses, this.blockRuleClasses);\n\t\tif (!!options.parserrules.inlineRuleList)this.inlineRuleClasses=createClassesList(options.parserrules.inlineRuleList, this.userClasses, this.inlineRuleClasses);\n\t}\n\tfor (var i = 0;i<this.blockRuleClasses.length;i++) alert (this.blockRuleClasses[i].rule.name);\n\t// Save the parse text\n\tthis.type = type || \"text/vnd.twbase\";\n\tthis.source = text || \"\";\n\tthis.options = options;\n};\n//realise the parser from the abstr parser\nvar  BaseWikiParser5= function (type,text,options) { \n\trequire(\"$:/core/modules/parsers/wikiparser/abstractwikiparser.js\")[\"AbstrWikiParser\"].\n\t\t\t\t\t\t\t\t\t\t\t\tcall(this,new ParserPrimer(type,text,options));\n}\nBaseWikiParser5.prototype =Object.create( \n\trequire(\"$:/core/modules/parsers/wikiparser/abstractwikiparser.js\")[\"AbstrWikiParser\"].prototype);\n\nexports[\"text/vnd.twbase\"] = BaseWikiParser5;\n\n})();\n\n",
            "title": "$:/core/modules/parsers/wikiparser/basewikiparser.js",
            "type": "application/javascript",
            "module-type": "parser"
        },
        "$:/core/modules/parsers/htmlparser.js": {
            "text": "/*\\\ntitle: $:/core/modules/parsers/htmlparser.js\ntype: application/javascript\nmodule-type: parser\n\nThe HTML parser displays text as raw HTML\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar HtmlParser = function(type,text,options) {\n\tvar src,sandbox;\n\tif(options._canonical_uri) {\n\t\tsrc = options._canonical_uri;\n\t} else if(text) {\n\t\tsrc = \"data:text/html;charset=utf-8,\" + encodeURIComponent(text);\n\t}\n\tif (options.parserrules && options.parserrules.sandbox) {\n\t\tsandbox = options.parserrules.sandbox;\n\t}\n\telse {\n\t\tsandbox = \"sandbox\";\n\t}\n\tthis.tree = [{\n\t\ttype: \"element\",\n\t\ttag: \"iframe\",\n\t\tattributes: {\n\t\t\tsrc: {type: \"string\", value: src},\n\t\t\tsandbox: {type: \"string\", value: sandbox}\n\t\t}\n\t}];\n};\n\nexports[\"text/html\"] = HtmlParser;\n\n})();\n\n",
            "title": "$:/core/modules/parsers/htmlparser.js",
            "type": "application/javascript",
            "module-type": "parser"
        },
        "$:/plugins/bj/flexitype/license": {
            "title": "$:/plugins/bj/flexitype/license",
            "text": "The MIT License (MIT)\n\nCopyright (c) 2014 Jeffrey Wikinson aka buggyj\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        "$:/plugins/bj/flexitype/readme": {
            "title": "$:/plugins/bj/flexitype/readme",
            "text": "Allows a user defined collection of tiddlywiki type parser rules to be associated with a (flexible) type. The flexible type has the form \n'\ntext/vnd.twbase<htmlp\n'\nwhere:\n\nvnd.twbase refers to the tiddlywiki5 parser stripped of its rules. \n\nhtmlp is an example of a user defined name of a json tiddler that contains options to define which rules will make up the new type.\n\nIn this example htmlp  contains\n`\n{\n  \"parserrules\": {\n    \"pragmaRuleList\": [],\n    \"blockRuleList\": [\n      \"html\"\n    ],\n    \"inlineRuleList\": [\n      \"html\",\n      \"prettylink\",\n      \"transcludeinline\",\n      \"entity\",\n      \"wikilink\"\n    ]\n  },\n  \"parseAsInline\": true\n}\n`\n\"prettylink\" etc are the tiddlywiki5 supplied 'parser rules'.  Non-tiddlywiki defined rules may also be be used.\n\nIt is also possible to defined pre-parsers (not shown in this example).\n\nProject home: http://bjtools.tiddlyspot.com\n"
        },
        "$:/core/modules/parsers/wikiparser/wikiadapter.js": {
            "text": "/*\\\ntitle: $:/core/modules/parsers/wikiparser/wikiadapter.js\ntype: application/javascript\nmodule-type: global\n\noverrides for wiki.js\n\n\\*/\n(function(){\n\t\nvar wiki = require(\"$:/core/modules/wiki.js\");\nwiki.mergesetting = function(items, adjustitems) {\n\tif (!adjustitems) return;//nothing to do\n\t$tw.utils.each(adjustitems,function(adjustitem, listname) {\n\t\tif (!!items[listname]) {\n\t\t\tif (items[listname] instanceof Array) {//merge lists\n\t\t\t\tvar i,baselen=items[listname].length;\n\t\t\t\tfor (var j=0; j<adjustitem.length; j++){\n\t\t\t\t\tfor ( i=0; i<baselen; i++) {\n\t\t\t\t\t\tif (adjustitem[j]===items[listname][i]) break;\n\t\t\t\t\t}\n\t\t\t\t\tif (i===baselen) items[listname].push(adjustitem[j]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\titems[listname]=adjustitem;//override item\n\t\t\t}\n\t\t} else items[listname]=adjustitem;//add new item\n\t\t\n\t})\n}\n/*\nrecursive function, retrives parseroptions from tiddlers/files\nreturns preparser, baseparser type and parserrules\n*/\nwiki.makeparsers=function(type,text,options){\n\tvar returns={};\n\t\t\n\t\tvar typeParts = type.split(\";flexibility=\");\n\t\tif (typeParts.length >1) {\n\t\t\tvar typeDialog =typeParts[1];//alert(typeDialog);\n\t\t\tvar  readdata=$tw.wiki.getTiddlerData(typeDialog);\n\t\t\t//read json tid (typeDialog )containing:\n\t\t\t\t// one string var of preparser eg text/type>html  \n\t\t\t\t// baseparser\n\t\t\t\t// parserdata\n\t\t\t\t// concaternate parserdata with baseparser -recursive\n\t\t\t\t// overload baserparser's preparser with this preparser\n\t\t\tif (!!readdata) {\n\t\t\t\tif (!!readdata.baserules) \n\t\t\t\t\treturns=this.makeparsers(readdata.baserules,text,options);\n\t\t\t\tif (!!readdata.parseAsInline) returns.parseAsInline =readdata.parseAsInline;\n\t\t\t\tif (!returns.parserrules) returns.parserrules = readdata.parserrules;\n\t\t\t\telse this.mergesetting(returns.parserrules,readdata.parserrules);\n\t\t\t\treturns.type = typeParts[0];//overrides basetype of baserules\n\t\t\t\tif (!!readdata.preparser) returns.preparser =readdata.preparser;//override baserule preparser\t\n\t\t\t\t//alert(parserdata);\n\t\t\t}\telse {\n\t\t\t\treturns.type=type;\n\t\t\t\treturns.parserrules=null;\n\t\t\t\treturns.preparser=null;\n\t\t\t}\n\t\t} else {\n\t\t\treturns.type=type;\n\t\t\treturns.parserrules=null;\n\t\t\treturns.preparser=null;\n\t\t}\n\t\treturn returns;\n\n}\nwiki.prepasstext =function(preparser,text, options) {\n\tvar preparserpart = preparser.split(\">\");\n\treturn this.renderText(preparserpart[1],preparserpart[0],text,options);\n}\n/*\nParse a block of text of a specified MIME type\n\ttype: content type of text to be parsed\n\ttext: text\n\toptions: see below\nOptions include:\n\tparseAsInline: if true, the text of the tiddler will be parsed as an inline run\n*/\nwiki.parseText = function(type,text,options) {\n\toptions = options || {};\n\tvar parserdata;\n\t// Select a parser\n\tif(type !== undefined) { //get type is undefined when built\n\t\tparserdata=this.makeparsers(type,text,options);\n\t\ttype=parserdata.type;\n\t\tif (!!parserdata.parseAsInline) options.parseAsInline =parserdata.parseAsInline;\n\t\tif (!!parserdata.preparser) text = this.prepasstext.call(this,parserdata.preparser,text,options);\n\t}\n\tvar Parser = $tw.Wiki.parsers[type];\n\tif(!Parser && $tw.config.fileExtensionInfo[type]) {\n\t\tParser = $tw.Wiki.parsers[$tw.config.fileExtensionInfo[type].type];\n\t}\n\tif(!Parser) {\n\t\tParser = $tw.Wiki.parsers[options.defaultType || \"text/vnd.tiddlywiki\"];\n\t}\n\tif(!Parser) {\n\t\treturn null;\n\t}\n\t// Return the parser instance\n\treturn new Parser(type,text,{\n\t\tparseAsInline: options.parseAsInline,\n\t\twiki: this,\n\t\t_canonical_uri: options._canonical_uri,\n\t\tparserrules:(type !== undefined)?parserdata.parserrules:null \n\t});\n};\n})();\n",
            "title": "$:/core/modules/parsers/wikiparser/wikiadapter.js",
            "type": "application/javascript",
            "module-type": "global"
        }
    }
}