author: JeffreyWilkinson
core-version: >=5.1.0
created: 20150212010546009
dependents: 
description: ckeditor adapter plugin
list: readme
plugin-type: plugin
source: https://github.com/buggyj/TW5-visualeditor
title: $:/plugins/bj/visualeditor
type: application/json
version: 0.0.5-alpha

{
    "tiddlers": {
        "$:/plugins/bj/visualeditor/ckedit.js": {
            "text": "/*\\\ntitle: $:/plugins/bj/visualeditor/ckedit.js\ntype: application/javascript\nmodule-type: widget\n\nckeditor adaptor\n\n\\*/\n\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nvar hasClass=function (e,theClass)\n{\n\tif(e.getAttribute('class')) {\n\t\tif(e.getAttribute('class').split(\" \").indexOf(theClass) != -1)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nvar applyStyleSheet = function(id,css) {\n\tvar el = document.getElementById(id);\n\tif(document.createStyleSheet) { // Older versions of IE\n\t\tif(el) {\n\t\t\tel.parentNode.removeChild(el);\n\t\t}\n\t\tdocument.getElementsByTagName(\"head\")[0].insertAdjacentHTML(\"beforeEnd\",\n\t\t\t'&nbsp;<style id=\"' + id + '\" type=\"text/css\">' + css + '</style>'); // fails without &nbsp;\n\t} else { // Modern browsers\n\t\tif(el) {\n\t\t\tel.replaceChild(document.createTextNode(css), el.firstChild);\n\t\t} else {\n\t\t\tel = document.createElement(\"style\");\n\t\t\tel.type = \"text/css\";\n\t\t\tel.id = id;\n\t\t\tel.appendChild(document.createTextNode(css));\n\t\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(el);\n\t\t}\n\t}\n};\nif($tw.browser) {\n\t//require(\"$:/plugins/bj/visualeditor/ckeditor.js\");\n\tif (typeof CKEDITOR != 'undefined')   {\n\t\tvar PLUSMODE  = (typeof $tw.wiki.getTiddler(\"$:/language/Docs/Types/text/x-perimental\")!='undefined');\n\n\t\tvar sty;\n\n\t\ttry {\n\t\t sty=$tw.wiki.getTiddlerData(\"$:/plugins/bj/visualeditor/styles.json\");\n\t\t} catch(e){ \n\t\t\talert(\"invalid style format\");\n\t\t\tsty=[];\n\t\t}\n\t\tif (PLUSMODE) sty.push({ \"name\": \"verbatim\",\"element\": \"span\",\"attributes\": {\"class\": \"verbatim\"}});\n\n\t\tCKEDITOR.stylesSet.add( 'default',sty);\n\t\tif (PLUSMODE) CKEDITOR.addCss($tw.wiki.getTiddlerData(\"$:/plugins/bj/visualeditor/verbatim.json\").verbatim);\n\t\tCKEDITOR.on( 'instanceReady', function( ev ) {\n\t\t\tvar blockTags = ['div','h1','h2','h3','h4','h5','h6','p','pre','li','blockquote','ul','ol',\n\t  'table','thead','tbody','tfoot','td','th',];\n\t\t\tvar rules = {\n\t\t\tindent : false,\n\t\t\tbreakBeforeOpen : true,\n\t\t\tbreakAfterOpen : false,\n\t\t\tbreakBeforeClose : false,\n\t\t\tbreakAfterClose : false\n\t\t};\n\n\t\tfor (var i=0; i<blockTags.length; i++) {\n\t\tev.editor.dataProcessor.writer.setRules( blockTags[i], rules );\n\t\t}\n\n\n\t\t});\n\n\t\t//BJ FixMe: figure out how to hide tw5 tags and macros from ckeditor\n\t\tCKEDITOR.config.protectedSource.push(/<\\/?\\$[^<]*\\/?>/g);\n\t\tCKEDITOR.config.protectedSource.push(/<<[^<]*>>/g);\n\t\t//CKEDITOR. config.protectedSource.push(/<\\?[\\s\\S]*?\\?>/g); // PHP Code\n\t\tCKEDITOR.config.protectedSource.push(/<code>[\\s\\S]*?<\\/code>/gi); // Code tags\n\t\tCKEDITOR.config.entities = false;\n\t}\n\n\tvar atiddler = $tw.wiki.getTiddler(\"$:/config/EditorTypeMappings/text/html\");\n\tif (atiddler==undefined) {\n\t\t\t\t$tw.wiki.addTiddler(new $tw.Tiddler($tw.wiki.getCreationFields(),\n\t\t\t\t{title:\"$:/config/EditorTypeMappings/text/html\", text:\"html\"}));\n\t}\n\tatiddler = $tw.wiki.getTiddler(\"$:/config/EditorTypeMappings/text/x-perimental\");\n\tif (atiddler==undefined) {\t\n\t\t\t\t$tw.wiki.addTiddler(new $tw.Tiddler($tw.wiki.getCreationFields(),\n\t\t\t\t\t{title:\"$:/config/EditorTypeMappings/text/x-perimental\", text:\"x-perimental\"}));\n\t}\n}\n})();\n\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar MIN_TEXT_AREA_HEIGHT = 100; // Minimum height of textareas in pixels\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar EditHtmlWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\nvar PLUSMODE  = (typeof $tw.wiki.getTiddler(\"$:/language/Docs/Types/text/x-perimental\")!='undefined');\n\n/*\nInherit from the base widget class\n*/\nEditHtmlWidget.prototype = new Widget();\n\nEditHtmlWidget.prototype.postRender = function() {\n\tvar self = this,\n\t\tcm;\n\tvar toWiki = function(text) {\n\t\t//if($tw.browser) alert(\"in towiki \"+text)\n\n\t\t//BJ FIXME - in theory the attribs can be in any order, so this may fail as it is\n\t\tvar newtext=\"\";\n\n\t\t newtext=text.replace(/^<p><span class=\\\"verbatim\\\".*?>([^<]*)<\\/span><\\/p>/,\n\t\tfunction(m,key,offset,str){\n                if (key.indexOf('<')!=-1) {// we have caputure some formatting - !abort\n\t\t\t\t\treturn m;\n\t\t\t\t}\n\t\t\t\treturn $tw.utils.htmlDecode(key)+\"\\n<!-- verbatim -->\";\n\n\t\t});\n\t\tnewtext =\n\t\tnewtext.replace(/<p><span class=\\\"verbatim\\\".*?>([^<]*)<\\/span><\\/p>/g,\n\t\tfunction(m,key,offset,str){\n                if (key.indexOf('<')!=-1) {// we have caputure some formatting - !abort\n\t\t\t\t\treturn m;\n\t\t\t\t}\n\t\t\t\treturn \"\\n<!-- nl verb -->\"+$tw.utils.htmlDecode(key)+\"<!-- atim -->\";\n\n\t\t\t\n\t\t});\n\t\tnewtext =\n\t\tnewtext.replace(/<span class=\\\"verbatim\\\".*?>([^<]*)<\\/span>/g,\n\t\tfunction(m,key,offset,str){\n                if (key.indexOf('<')!=-1) {// we have caputure some formatting - !abort\n\t\t\t\t\treturn m;\n\t\t\t\t}\n\t\t\t\treturn \"<!-- verb -->\"+$tw.utils.htmlDecode(key)+\"<!-- atim -->\";\n\t\t});\n\t\t//if($tw.browser) alert(newtext);\n\t\treturn newtext;\n\t}\n\n\tif($tw.browser && window.CKEDITOR && this.editTag === \"textarea\") {\n\t\t\n\t\tvar ck =\"editor\"+ Math.random();\n\t\tthis.domNodes[0].firstChild.setAttribute(\"name\",ck);\n\t\tthis.domNodes[0].firstChild.setAttribute(\"id\",ck);\n\t\tvar config;\n\t\ttry {\n\t\t    config= $tw.wiki.getTiddlerData(\"$:/plugins/bj/visualeditor/config.json\");\n\t\t} catch(e) {\n\t\t\talert(\"invalid config format\");\n\t\t\tconfig = [];\n\t\t}\n\t\tCKEDITOR.replace(ck, config);//,\n\t\t\t//extraPlugins:$tw.wiki.getTiddlerText(\"$:/plugins/bj/visualeditor/extraplugins.tid\")});\t\n\t\t//BJ: note that we have statically loaded the style sheet already,\n\t\t//therefore it is not possible to load a different skin here\n\t\t//CKEDITOR.replace(ck,{ extraPlugins : 'divarea'})\n\n\t\tCKEDITOR.instances[ck].on('change', \n\t\t\tfunction() { \n\t\t\t\tif (PLUSMODE && self.edittype == 'text/x-perimental') {\n\t\t\t\t\tself.saveChanges(toWiki(CKEDITOR.instances[ck].getData()));\n\t\t\t\t} else {\n\t\t\t\t\tself.saveChanges(CKEDITOR.instances[ck].getData());\n\t\t\t\t} \n\t\t\t}\n\t\t);\n\t} \n};\n/*\nBJ the follow code is from tw5 core, with some minor modifications\n*******************************************************************\nEdit-html widget\n*/\n/*\nRender this widget into the DOM\n*/\nEditHtmlWidget.prototype.render = function(parent,nextSibling) {\n\tvar self = this;\n\t// Save the parent dom node\n\tthis.parentDomNode = parent;\n\t// Compute our attributes\n\tthis.computeAttributes();\n\t// Execute our logic\n\tthis.execute();\n\tvar fromWiki = function(text) {\n\t\tvar preAmble='<span class=\"verbatim\">';\n\t\tvar index=1;\n\t\t//seperate the /define .../end section\n\t\ttext = text.split(\"<\\!-- verbatim -->\");\n\t\tif (text.length==1) //no preamble defined\n\t\t\tindex=0;\n\t\telse\n\t\t\ttext[0]= preAmble+$tw.utils.htmlEncode(text[0])+'</span>'\n\t\ttext[index] = \ttext[index].replace(/^<\\!-- nl verb -->([\\s\\S]*?)<\\!-- atim -->/mg,\n\t\tfunction(m,key,offset,str){//alert(key);\n\t\t\treturn '<p>'+preAmble+$tw.utils.htmlEncode(key)+'</span>'+'</p>';\n\t\t});//alert (\"newtext \"+text[index]);\n\t\ttext[index] = \ttext[index].replace(/<\\!-- verb -->([\\s\\S]*?)<\\!-- atim -->/g,\n\t\tfunction(m,key,offset,str){//alert(key);\n\t\t\treturn preAmble+$tw.utils.htmlEncode(key)+'</span>';\n\t\t});\n\t\t//alert (\"newtext \"+text.join(\"\"));\n\t\treturn text.join(\"\");\n\t}\n\t// Create our element\n\tvar outerDomNode = this.document.createElement('div');\n\t\touterDomNode.className = \"tw-ckeditor-instance\";\n\tvar domNode = this.document.createElement(this.editTag);\n\tif(this.editType) {\n\t\tdomNode.setAttribute(\"type\",this.editType);\n\t}\n\tif(this.editPlaceholder) {\n\t\tdomNode.setAttribute(\"placeholder\",this.editPlaceholder);\n\t}\n\t// Assign classes\n\tif(this.editClass) {\n\t\tdomNode.className = this.editClass;\n\t}\n\t// Set the text\n\tvar editInfo = this.getEditInfo();\n\tif(this.editTag === \"textarea\") {\n\t\tif (PLUSMODE && this.edittype == 'text/x-perimental') {\n\t\t\tdomNode.appendChild(this.document.createTextNode(fromWiki(editInfo.value)));\n\t\t} else  {\n\t\t\tdomNode.appendChild(this.document.createTextNode(editInfo.value));\n\t\t} \n\t} else {\n\t\tdomNode.setAttribute(\"value\",editInfo.value)\n\t}\n    outerDomNode.appendChild(domNode);\n\t// Insert the element into the DOM\n\tparent.insertBefore(outerDomNode,nextSibling);\n\tthis.domNodes.push(outerDomNode);\n\tif(this.postRender) {\n\t\tthis.postRender();\n\t}\n\t// Fix height\n\tthis.fixHeight();\n};\n\n/*\nGet the tiddler being edited and current value\n*/\nEditHtmlWidget.prototype.getEditInfo = function() {\n\t// Get the edit value\n\tvar self = this,\n\t\tvalue,\n\t\tupdate;\n\tif(this.editIndex) {\n\t\tvalue = this.wiki.extractTiddlerDataItem(this.editTitle,this.editIndex,this.editDefault);\n\t\tupdate = function(value) {\n\t\t\tvar data = self.wiki.getTiddlerData(self.editTitle,{});\n\t\t\tif(data[self.editIndex] !== value) {\n\t\t\t\tdata[self.editIndex] = value;\n\t\t\t\tself.wiki.setTiddlerData(self.editTitle,data);\n\t\t\t}\n\t\t};\n\t} else {\n\t\t// Get the current tiddler and the field name\n\t\tvar tiddler = this.wiki.getTiddler(this.editTitle);\n\t\tif(tiddler) {\n\t\t\t// If we've got a tiddler, the value to display is the field string value\n\t\t\tvalue = tiddler.getFieldString(this.editField);\n\t\t} else {\n\t\t\t// Otherwise, we need to construct a default value for the editor\n\t\t\tswitch(this.editField) {\n\t\t\t\tcase \"text\":\n\t\t\t\t\tvalue = \"Type the text for the tiddler '\" + this.editTitle + \"'\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"title\":\n\t\t\t\t\tvalue = this.editTitle;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvalue = \"\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(this.editDefault !== undefined) {\n\t\t\t\tvalue = this.editDefault;\n\t\t\t}\n\t\t}\n\t\tupdate = function(value) {\n\t\t\tvar tiddler = self.wiki.getTiddler(self.editTitle),\n\t\t\t\tupdateFields = {\n\t\t\t\t\ttitle: self.editTitle\n\t\t\t\t};\n\t\t\tupdateFields[self.editField] = value;\n\t\t\tself.wiki.addTiddler(new $tw.Tiddler(self.wiki.getCreationFields(),tiddler,updateFields,self.wiki.getModificationFields()));\n\t\t};\n\t}\n\treturn {value: value, update: update};\n};\n\n/*\nCompute the internal state of the widget\n*/\nEditHtmlWidget.prototype.execute = function() {\n\t// Get our parameters\n\tthis.editTitle = this.getAttribute(\"tiddler\",this.getVariable(\"currentTiddler\"));\n\tthis.editField = this.getAttribute(\"field\",\"text\");\n\tthis.editIndex = this.getAttribute(\"index\");\n\tthis.editDefault = this.getAttribute(\"default\");\n\tthis.editClass = this.getAttribute(\"class\");\n\tthis.editPlaceholder = this.getAttribute(\"placeholder\");\n\tthis.editFocusPopup = this.getAttribute(\"focusPopup\");\n\tthis.onkeyupdate = this.getAttribute(\"onkeyupdate\",\"yes\"); \n\t\t// Get the content type of the thing we're editing\n\tthis.edittype;\n\tif(this.editField === \"text\") {\n\t\tvar tiddler = this.wiki.getTiddler(this.editTitle);\n\t\tif(tiddler) {\n\t\t\tthis.edittype = tiddler.fields.type;\n\t\t}\n\t}\n\t// Get the editor element tag and type\n\tvar tag,type;\n\tif(this.editField === \"text\") {\n\t\ttag = \"textarea\";\n\t} else {\n\t\ttag = \"input\";\n\t\tvar fieldModule = $tw.Tiddler.fieldModules[this.editField];\n\t\tif(fieldModule && fieldModule.editTag) {\n\t\t\ttag = fieldModule.editTag;\n\t\t}\n\t\tif(fieldModule && fieldModule.editType) {\n\t\t\ttype = fieldModule.editType;\n\t\t}\n\t\ttype = type || \"text\";\n\t}\n\t// Get the rest of our parameters\n\tthis.editTag = this.getAttribute(\"tag\",tag);\n\tthis.editType = this.getAttribute(\"type\",type);\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nEditHtmlWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\t// Completely rerender if any of our attributes have changed\n\tif(changedAttributes.tiddler || changedAttributes.field || changedAttributes.index) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else if(changedTiddlers[this.editTitle]) {\n\t\tthis.updateEditor(this.getEditInfo().value);\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n/*\nUpdate the editor with new text. This method is separate from updateEditorDomNode()\nso that subclasses can override updateEditor() and still use updateEditorDomNode()\n*/\nEditHtmlWidget.prototype.updateEditor = function(text) {\n\tthis.updateEditorDomNode(text);\n};\n\n/*\nUpdate the editor dom node with new text\n*/\nEditHtmlWidget.prototype.updateEditorDomNode = function(text) {\n\t// Replace the edit value if the tiddler we're editing has changed\n\tvar domNode = this.domNodes[0].firstChild;\n\tif(!domNode.isTiddlyWikiFakeDom) {\n\t\tif(this.document.activeElement !== domNode) {\n\t\t\tdomNode.value = text;\n\t\t}\n\t\t// Fix the height if needed\n\t\tthis.fixHeight();\n\t}\n};\n\n/*\nFix the height of textareas to fit their content\n*/\nEditHtmlWidget.prototype.fixHeight = function() {\n\tvar self = this,\n\t\tdomNode = this.domNodes[0];\n\tif(domNode && !domNode.isTiddlyWikiFakeDom && this.editTag === \"textarea\") {\n\t\t$tw.utils.nextTick(function() {\n\t\t\t// Resize the textarea to fit its content, preserving scroll position\n\t\t\tvar scrollPosition = $tw.utils.getScrollPosition(),\n\t\t\t\tscrollTop = scrollPosition.y;\n\t\t\t// Set its height to auto so that it snaps to the correct height\n\t\t\tdomNode.style.height = \"auto\";\n\t\t\t// Calculate the revised height\n\t\t\tvar newHeight = Math.max(domNode.scrollHeight + domNode.offsetHeight - domNode.clientHeight,MIN_TEXT_AREA_HEIGHT);\n\t\t\t// Only try to change the height if it has changed\n\t\t\tif(newHeight !== domNode.offsetHeight) {\n\t\t\t\tdomNode.style.height =  newHeight + \"px\";\n\t\t\t\t// Make sure that the dimensions of the textarea are recalculated\n\t\t\t\t$tw.utils.forceLayout(domNode);\n\t\t\t\t// Check that the scroll position is still visible before trying to scroll back to it\n\t\t\t\tscrollTop = Math.min(scrollTop,self.document.body.scrollHeight - window.innerHeight);\n\t\t\t\twindow.scrollTo(scrollPosition.x,scrollTop);\n\t\t\t}\n\t\t});\n\t}\n};\n\n/*\nHandle a dom \"input\" event\n*/\nEditHtmlWidget.prototype.handleInputEvent = function(event) {\n\tthis.saveChanges(this.domNodes[0].firstChild.value);\n\tthis.fixHeight();\n\treturn true;\n};\n\nEditHtmlWidget.prototype.handleFocusEvent = function(event) {\n\tif(this.editFocusPopup) {\n\t\t$tw.popup.triggerPopup({\n\t\t\tdomNode: this.domNodes[0].firstChild,\n\t\t\ttitle: this.editFocusPopup,\n\t\t\twiki: this.wiki,\n\t\t\tforce: true\n\t\t});\n\t}\n\treturn true;\n};\n\nEditHtmlWidget.prototype.saveChanges = function(text) {\n\tvar editInfo = this.getEditInfo();\n\tif(text !== editInfo.value) {\n\t\teditInfo.update(text);\n\t}\n};\n\nexports[\"edit-html\"] = EditHtmlWidget;\n$tw.utils.registerFileType(\"text/x-perimental\",\"utf8\",\".perimental\");\nexports[\"edit-x-perimental\"] = EditHtmlWidget;\n\n})();\n\n",
            "title": "$:/plugins/bj/visualeditor/ckedit.js",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/bj/visualeditor/styles.json": {
            "type": "application/json",
            "title": "$:/plugins/bj/visualeditor/styles.json",
            "module-type": "library",
            "text": "[\n\t{ \"name\": \"Blue Title\",     \"element\": \"h3\",      \"styles\": { \"color\": \"Blue\" } },\n\t{ \"name\": \"Red Title\",      \"element\": \"h3\",      \"styles\": { \"color\": \"Red\" } },\n\t{ \"name\": \"Marker: Yellow\",\t\"element\": \"span\",    \"styles\": { \"background-color\": \"Yellow\"} },\n\t{ \"name\": \"Marker: Red\",\t\"element\": \"span\",    \"styles\": { \"background-color\": \"Red\"} },\n\t{ \"name\": \"Marker: Green\",\t\"element\": \"span\",    \"styles\": { \"background-color\": \"Lime\" } }\n]\n\n"
        },
        "$:/plugins/bj/visualeditor/config.json": {
            "type": "application/json",
            "title": "$:/plugins/bj/visualeditor/config.json",
            "module-type": "library",
            "text": "{\n\"removePlugins\":\"smiley,wsc,scayt,forms,save,preview,print\",\n\"customConfig\":\"\",\n\"language\" : \"en\",\n\"defaultLanguage\" : \"en\",\n\"contentsCss\" : \"\",\n\"disableNativeSpellChecker\" : false,\n\"resize_enabled\" : false \n}\n"
        },
        "$:/plugins/bj/visualeditor/verbatim.json": {
            "type": "application/json",
            "title": "$:/plugins/bj/visualeditor/verbatim.json",
            "module-type": "library",
            "text": "{\n\"verbatim\":\".verbatim{background-color: red;border:2px solid;}\"\n}\n"
        },
        "$:/plugin/bj/visualeditor/includelib": {
            "title": "$:/plugin/bj/visualeditor/includelib",
            "description": "load the external lib",
            "tags": "$:/core/wiki/rawmarkup",
            "text": "<script src=\"http://cdnjs.cloudflare.com/ajax/libs/ckeditor/4.3.2/ckeditor.js\"></script>\n"
        },
        "$:/plugins/bj/visualeditor/readme": {
            "title": "$:/plugins/bj/visualeditor/readme",
            "text": "\nthe tiddler\n`\n$:/plugin/bj/visualeditor/includelib\n`\nneeds to contain the location of the ckeditor lib. The default is\n`\n<script src=\"http://cdnjs.cloudflare.com/ajax/libs/ckeditor/4.3.2/ckeditor.js\"></script>\n`\n`\n<script src=\"file:///path/to/ckeditor.js\"></script>\n`\n"
        },
        "$:/language/Docs/Types/text/x-htmlp": {
            "title": "$:/language/Docs/Types/text/x-htmlp",
            "description": "ckeditor usage",
            "name": "text/x-htmlp",
            "group": "Text"
        },
        "$:/config/EditorTypeMappings/text/x-htmlp": {
            "title": "$:/config/EditorTypeMappings/text/x-htmlp",
            "text": "html"
        }
    }
}